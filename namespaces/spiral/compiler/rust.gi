# Copyright (c) 2023, LoÃ¯c Fejoz
# See LICENSE for details


# -------------------
# TYPES
# -------------------

re.rustprint := self >> Print(self.args[1].rustprint(), ".re");
im.rustprint := self >> Print(self.args[1].rustprint(), ".im");

TComplex.rusttype := "struct{double r,i;}";
TDouble.rusttype  := "f64";
TReal.rusttype := "f32";
TInt.rusttype     := "int32";
TUInt.rusttype := "uint32";
TChar.rusttype := "byte";

Class(RustUnparserBase, Unparser, rec(
    preprocess := (self, o) >> o,
    preprocess_init := (self, o) >> o,

    # example: includes := [ "<math.h>" ]
    includes := [ "num_complex::Complex", "crlibm::*" ],

    generated_by := Concat("#[allow(unused_imports)]\
/*\
 * This code was generated by Spiral ", SpiralVersion, ", www.spiral.net\
 * Rust version\
 */\
\n"),

    extraHeader := "",

    header_top := meth(self, subname, o)
        local precomputed_data;
        Print(self.generated_by);

        self.fileinfo(self.opts);

        DoForAll(Concatenation(self.includes, self.opts.includes),
             inc -> Print("use ", inc, ";\n"));

        if IsBound(o.dimensions) then Print("/* ", o.dimensions, " */\n"); fi;

        if IsBound(o.runtime_data) then
            DoForAll(o.runtime_data, x->Print(self.opts.arrayDataModifier, " ",
                                              self.declare(x.t, x, 0, 4), ";\n"));
            Print("\n");
        fi;

        precomputed_data := List(Collect(o, data), x->[x.var, x.value]);
    DoForAll(precomputed_data, d -> When(IsArrayT(d[1].t), self.genData(d[1], d[2])));
    end,

    header_func := meth(self, subname, o)
        local loopvars;
        Print("    #[allow(unused_parens)]\n    pub fn ", self.opts.funcModifier, " ", subname, "(",
          self.declare(Y.t, Y, 0, 0), ", ", self.declare(X.t, X, 0, 0));

        if IsBound(self.opts.sig) then
            DoForAll(self.opts.sig, p -> Print(", ", self.declare(p.t, p, 0, 0)));
        fi;
        Print(") {");

        loopvars := Set(List(Collect(o, @(1).cond(IsLoop)), x->x.var));
        if loopvars <> [] then Print(Blanks(4), "int ", PrintCS(loopvars), ";\n"); fi;
    end,

    header := meth(self, subname, o)
        self.header_top(subname, o);
        self.header_func(subname, o);
    end,

    footer := meth(self, subname, o)
        local init, loopvars;
        Print("    }}\n");
        Print("    #[allow(unused_parens)]\n    pub fn init_", subname, "() {unsafe{\n");
        if IsBound(o.runtime_init) then # unparse initialization code

            loopvars := Union(List(o.runtime_init, cc -> List(Collect(cc, @(1).cond(IsLoop)), x->x.var)));
            if loopvars <> [  ]  then
                Print(Blanks(4), "int ", PrintCS(loopvars), ";\n"); fi;
            for init in o.runtime_init do
                init := self.preprocess_init(init);
                self(SReduce(init, o), 4, 4);
            od;
        fi;
        Print("    }\n");
    end,

    genData := (self, v, val) >> Print(
        When(IsArrayT(val.t), self.opts.arrayDataModifier, self.opts.scalarDataModifier), " ",
        self.declare(val.t, v, 0, 4), " = ", self(val,2,2), ";\n",
        When(IsArrayT(val.t), "\n", "")),

    ####################
    ## General
    ####################
    atomic  := (self,o,i,is) >> Print(o),
    param   := (self,o,i,is) >> Print(o.id),
    var     := (self,o,i,is) >> Print(
        When(
            o.id in self.fields,
            "self.",
            "")
        ,o.id),
    Loc     := (self,o,i,is) >> o.rustprint(),

    ####################
    ## Commands
    ####################

    asmvolatile := (self,o,i,is) >> AsmX86Unparser.asmvolatile(o.asm),

    skip := (self,o,i,is) >> Print(Blanks(i), "/* skip */\n"),

    noUnparse :=(self,o,i,is) >> Print(o.str),

    assign := (self,o,i,is) >> Print(Blanks(i), When(ObjId(o.loc)=nth, "", "let "), self(o.loc,i,is), " = ", self(o.exp,i,is), ";\n"),

    assign_acc := (self,o,i,is) >> Print(Blanks(i), self(o.loc,i,is), " += ", self(o.exp,i,is), ";\n"),

    chain    := (self,o,i,is) >> DoForAll(o.cmds, c -> self(c, i, is)),
    brackets := (self,o,i,is) >> self.printf("($1)", [o.args[1]]),

    unparseChain := (self,o,i,is) >> DoForAll(o.cmds, c -> self(c, i, is)),

    kern := (self, o, i, is) >> When( IsBound(self.opts.SimFlexKernelFlag) and IsBound(o.bbnum),
        Print(
            "#if !defined(KERN) || defined(KERN", String(o.bbnum), ")\n",
            self(o.cmd, i, is),
            "#endif\n"
        ),
        self(o.cmd, i, is)
    ),
    unroll_cmd := ~.chain,

    # all datas are handled in the header, just proceed to children
    data := (self,o,i,is) >> Print(
        When(not IsArrayT(o.var.t), Print(Blanks(i), self.genData(o.var, o.value))),
        self(o.cmd, i, is)
    ),

    _lt := " <= ",
    loop := (self,o,i,is) >> Checked(IsRange(o.range),
        let(v := o.var, lo := o.range[1], hi := Last(o.range),
            Print(Blanks(i), "for(", v, " = ", lo, "; ", v, self._lt, hi, "; ", v, "++) {\n",
                self(o.cmd,i+is,is),
                Blanks(i), "}\n"))),

    loopn := (self,o,i,is) >>
        let(v := o.var, n := o.range,
            Print(Blanks(i), "for(", v, " = ", 0, "; ", v, self._lt, self(n-1,i,is), "; ", v, "++) {\n",
                self(o.cmd,i+is,is),
                Blanks(i), "}\n")),

    doloop := (self,o,i,is) >>
        let(v := o.var, n := o.range,
            Print(Blanks(i), "do {\n",
                self(o.cmd,i+is,is),
                Blanks(i), "} while( ", self(v,i,is), "<", self(n,i,is), " );\n")),

    loopn := (self, o, i, is) >> self.loop(o, i, is),

    IF := (self,o,i,is) >> Print(Blanks(i),
        "if ", self(o.cond,i,is), " {\n", self(o.then_cmd,i+is,is), Blanks(i), "}",
        When(o.else_cmd = skip(),
             "\n",
             Print(" else {\n", self(o.else_cmd,i+is,is), Blanks(i), "}\n"))),

    DOWHILE := (self,o,i,is) >> Print(Blanks(i),
    "do \n",  Blanks(i), "{\n", self(o.then_cmd,i+is,is), Blanks(i), "}",
        "while (", self(o.cond,i,is), ");\n" ),

    WHILE := (self,o,i,is) >> Print(Blanks(i),
    "while (", self(o.cond,i,is), ")\n" ,
    Blanks(i), "{\n", self(o.then_cmd,i+is,is), Blanks(i), "}\n"),

    PRINT := (self,o, i, is) >> Print(Blanks(i),
        "print!(\"", o.fmt, "\"",
            When(o.vars <> [],
                Print(", ",
                    DoForAll( DropLast(o.vars,1),
                        e -> Print(self(e,i,is), ", ")
                    ),
                    self(Last(o.vars),i,is)
                ),
                Print("")
            ),
            ");\n"
    ),

    multi_if := meth(self,o,i,is)
        local j, conds;
    conds := o.args { [1..Int(Length(o.args)/2)]*2 - 1 };

        # degenerate case, no conditions, else branch only
        if Length(o.args)=1 then 
        self(o.args[1], i, is);

    # generate switch stmt
    elif ForAll(conds, c -> ObjId(c)=eq and ObjId(c.args[1]) in [var,param] and c.args[1]=conds[1].args[1] and IsValue(c.args[2])) then
        Print(Blanks(i), "switch(", self(conds[1].args[1], i, is), ") { \n");
            j := 1;
            while j < Length(o.args) do
                Print(Blanks(i+Int(is/2)), "case ", self(o.args[j].args[2], i, is), ": ");
        Cond(ObjId(o.args[j+1])=ret, 
             Print(self(o.args[j+1],0,is), Blanks(i+is), "break;\n "),
             Print("{\n", self(o.args[j+1],i+is,is), Blanks(i+is), "break; }\n"));
        j := j+2;
            od;
            # Print out the else branch if it exists (j=Length)
            if j = Length(o.args) then 
        Print(Blanks(i+Int(is/2)), "default: ");
        Cond(ObjId(o.args[j])=ret, 
             Print(self(o.args[j], 0, is)),
             Print("{\n", self(o.args[j], i+is, is), Blanks(i+Int(is/2)), "}\n"));
            fi;
        Print(Blanks(i), "}\n");

    # general IF cascade
    else

            j := 1;
            while j < Length(o.args) do
                Print(Blanks(i), When(j<>1, "else "), "if (",
                      self(o.args[j],  i+is,is), ") {\n",
                      self(o.args[j+1],i+is,is), Blanks(i), "}\n");
        j := j+2;
            od;
            # Print out the else branch if it exists (j=Length)
            if j = Length(o.args) then 
        Print(Blanks(i), "else {\n",
                      self(o.args[j],  i+is, is), Blanks(i), "}\n");
            fi;
    fi;
    end,

    zallocate := (self, o, i, is) >> Print(
        self(allocate(o.loc,o.exp),i,is),
        Blanks(i),"memset(",self(o.loc, i, is)," ,'\\0', sizeof(",
        self.declare(o.exp.t,[],0,0), ") * ", self(o.exp.size,i,is), ");\n"),
#        Blanks(i),"for(int iinit = 0; iinit <  ",self(o.exp.size,i,is),"; iinit++)\n",
#        Blanks(i),"    ", self(o.loc, i, is),"[iinit]=0;\n"),

    ####################
    ## Expressions
    ####################

    RewritableObjectExp := (self,o,i,is) >> Print(o.name, self.pinfix(o.rChildren(), ", ")),
    Exp := (self,o,i,is) >> Print(o.name, self.pinfix(o.args, ", ")),
    ExpCommand := (self,o,i,is) >> Print(Blanks(i), o.name, self.pinfix(o.args, ", "), ";\n"),
    Command := (self,o,i,is) >> Print(Blanks(i), o.name, self.pinfix(o.rChildren(), ", "), ";\n"),
    call := (self,o,i,is) >> Print(Blanks(i), self(o.args[1],i,is), self.pinfix(Drop(o.args,1), ", "), ";\n"),
    errExp := (self, o, i, is) >> self(o.t.zero(), i, is),

    eq  := (self, o, i, is) >> self.condinfix(o.args, " == ", " && "),
    neq := (self, o, i, is) >> self.condinfix(o.args, " != ", " && "),
    geq := (self, o, i, is) >> self.condinfix(o.args, " >= ", " && "),
    leq := (self, o, i, is) >> self.condinfix(o.args, " <= ", " && "),
    gt  := (self, o, i, is) >> self.condinfix(o.args, " > ",  " && "),
    lt  := (self, o, i, is) >> self.condinfix(o.args, " < ",  " && "),

    nth := (self,o,i,is) >> Print(self(o.loc,i,is), "[", self(o.idx,i,is), "]"),
    deref := (self,o,i,is) >> Print("*(", self(o.loc,i,is), ")"),
    addrof := (self,o,i,is) >> Print("&(", self(o.loc,i,is), ")"),
    fdiv := (self,o,i,is) >> Print(
        "(((", self(o.args[1],i,is), ") as ",  self.declare(TReal, [],i,is),
        ") / (", self(o.args[2],i,is), " as ", self.declare(TReal, [],i,is), "))"),
    add := (self,o,i,is) >> self.pinfix(o.args, " + "),
    logic_and := (self,o,i,is) >> self.ppinfix(o.args, " && "),
    logic_or := (self,o,i,is) >> self.ppinfix(o.args, " || "),
    logic_neg := (self,o,i,is) >> Print("( !(",self(o.args[1],i,is), ") )"),
    sub := (self,o,i,is) >> self.pinfix(o.args, " - "),
    neg := (self,o,i,is) >> Print("-(", self(o.args[1],i,is), ")"),

    mul := (self,o,i,is) >> self.pinfix(o.args, "*"),
    div := (self,o,i,is) >> self.pinfix(o.args, " / "),
    idiv := (self,o,i,is) >> self.pinfix(o.args, " / "),
    imod := (self,o,i,is) >> self.pinfix(List(o.args, x -> When(IsPtrT(x.t), tcast(TSym("usize"),x) ,x)), " % "),
    no_mod := (self,o,i,is) >> self(o.args[1],i,is),
    re     := (self,o,i,is) >> self.printf("($1).re", [o.args[1]]),
    im     := (self,o,i,is) >> self.printf("($1).im", [o.args[1]]),
    cxpack := (self,o,i,is) >> self.printf("($1) + _Complex_I*($2)", [o.args[1], o.args[2]]),

    bin_and := (self,o,i,is) >> Print("((", self.pinfix(List(o.args, x -> When(IsPtrT(x.t), tcast(TSym("usize"),x) ,x)), ")&("), "))"),
    bin_or := (self,o,i,is) >> Print("((", self.pinfix(List(o.args, x -> When(IsPtrT(x.t), tcast(TSym("usize"),x) ,x)), ")|("), "))"),
    bin_xor := (self,o,i,is) >> Print("((", self(o.args[1],i,is), ")^(", self(o.args[2],i,is),"))"),
	
	bin_shl := (self,o,i,is) >> self.pinfix(o.args, " << "),
	bin_shr := (self,o,i,is) >> self.pinfix(o.args, " >> "),

    abs := (self,o,i,is) >> Print("abs(", self(o.args[1],i,is), ")"),

    floor := (self,o,i,is) >> Print("((int)(", self(o.args[1],i,is), "))"),

    lShift := (self,o,i,is) >> Cond(IsBound(o.args[3]),
            Error("non implemented"),
            Print("((",self(o.args[1],i,is),") << (",self(o.args[2],i,is), "))")),

    rShift := (self,o,i,is) >> Cond(IsBound(o.args[3]),
            Error("non implemented"),
            Print("((",self(o.args[1],i,is),") >> (",self(o.args[2],i,is), "))")),

    arith_shr := (self, o, i, is) >> Cond( o.t.isSigned(), self.printf("(($1) >> ($2))", [o.args[1], o.args[2]]),
                                           Error("implement arith_shr for unsigned data type")),
    arith_shl := (self, o, i, is) >> Cond( o.t.isSigned(), self.printf("(($1) \<\< ($2))", [o.args[1], o.args[2]]),
                                           Error("implement arith_shl for unsigned data type")),
    
    xor := meth(self,o,i,is)
        Print("((", self(o.args[1],i,is));
        DoForAll(o.args{[2..Length(o.args)]}, e -> Print(")^(", self(e,i,is)));
        Print("))");
    end,

    max := (self,o,i,is) >> self(cond(geq(o.args[1],o.args[2]),o.args[1],o.args[2]),i,is),

    min := (self,o,i,is) >> self(cond(leq(o.args[1],o.args[2]),o.args[1],o.args[2]),i,is),

    log := (self,o,i,is) >> Cond( Length(o.args)=1,
        Cond( o.t = T_Real(32) or (IsBound(self.opts.TRealRusttype) and self.opts.TRealRusttype = "f32"),
                self.printf("logf($1)", [o.args[1]]),
              # else
              self.printf("log((f64)($1))", [o.args[1]])),
        Cond( o.t = T_Real(32) or (IsBound(self.opts.TRealRusttype) and self.opts.TRealRusttype = "f32"),
                self.printf("logf($1)/logf($2)", [o.args[1], o.args[2]]),
              # else
              self.printf("log((f64)($1))/log((f64)($2))", [o.args[1], o.args[2]]))),
    
    pow := (self,o,i,is) >> Cond( 
        o.args[2]=2, 
            self(mul(o.args[1], o.args[1]), i, is),
        # else
            Error("Implement pow()")),

    sqrt  := (self,o,i,is) >> self.printf("sqrt($1)",    [o.args[1]]),
    rsqrt := (self,o,i,is) >> self.printf("$1/sqrt($2)", [o.t.one(), o.args[1]]),
    
    cond := (self,o,i,is) >> Cond(
      Length(o.args)=3,
          Cond(ObjId(o.args[3]) = errExp, 
           self(o.args[2], i, is), 
               Print("((",self(o.args[1],i,is),") ? (",self(o.args[2],i,is),") : (",self(o.args[3],i,is),"))")),

      # NOTE: no else case here, maybe just leave it like this?
      Length(o.args)=2, 
          self(o.args[2],i,is),

      # more than 3 args: do a binsplit trick
      Print("((",self(o.args[1],i,is),") ? (",self(o.args[2],i,is),") : ",
      self(ApplyFunc(cond, Drop(o.args, 2)), i,is),")")),

    _decval :=(self, v) >> let(pf := When(IsBound(self.opts.valuePostfix), self.opts.valuePostfix, ""),
            Print(v, pf)),

    Value := (self,o,i,is) >>
        Cond(
        o.t = TComplex, let(c:=Complex(o.v), re:=ReComplex(c), im:=ImComplex(c),
            Cond(re=0 and im=1,  Print(self.opts.c99.I),
                 re=0 and im=-1, Print("(- ", self.opts.c99.I, ")"),
                 im=0,           Print(self._decval(re)),
                 re=0,           Print("(", self._decval(im), " * ", self.opts.c99.I, ")"),
                 im < 0,         Print("(", self._decval(re), " - ", self.opts.c99.I, " * ", self._decval(-im), ")"),
                 Print("(", self._decval(re), " + ", self.opts.c99.I, " * ", self._decval(im), ")"))),

        o.t = TReal, let(
            v := Cond(IsCyc(o.v), ReComplex(Complex(o.v)), o.v),
            Cond(v < 0, 
            Print("(", self._decval(v), ")"),
            Print(self._decval(v)))),

        IsArray(o.t),                      Print("{", WithBases(self, rec(infixbreak:=4)).infix(o.v, ", ", i), "}"),
        o.v < 0,                           Print("(", o.v, ")"),
        o.t = TBool,                       When(o.v in [true, 1], Print("true"), Print("false")),

        o.t = TUInt,                       Print(o.v, "u"), 
                                           Print(o.v)
    ),

    ##########################
    ## Types and declarations
    ##########################

    decl_field := meth(self, v, i, is)
        self.fields := When(IsBound(self.fields), Concat(self.fields, [v.id]), [v.id]);
        Print(Blanks(i+1), v, ": ", self.(v.t.name)(v.t, [], i, is), ",\n");
    end,

    decl := meth(self,o,i,is)
        local arrays, other;
        # skip variables declaration, just print body 
        [arrays, other] := SplitBy(o.vars, x->IsArray(x.t));
        if i=0  then
            Print("\npub struct ", self.opts.subName, "{\n");
            DoForAll(arrays, v -> self.decl_field(v, i, is));
            Print("}\n\nimpl ", self.opts.subName, "{\n");
            Print(Blanks(i+1), "pub fn new() -> ", self.opts.subName, " {\n");
            Print(Blanks(i+2), self.opts.subName, " {\n");
            DoForAll(arrays, v -> Print(Blanks(i+3), v, ": [0.0", self.(v.t.t.name)(v.t.t, [], i, is), "; ", v.t.size ,"],\n"));
            Print(Blanks(i+2), "}\n", Blanks(i+1), "}\n");
            self(o.cmd, i+1, is);
            Print("}\n");
        else
            DoForAll(arrays, v -> Print(Blanks(i), "let mut ", v, ": ", self.(v.t.name)(v.t, [], i, is), " = [0.0", self.(v.t.t.name)(v.t.t, [], i, is), "; ", v.t.size ,"];\n"));
            self(o.cmd, i, is);
        fi;
    end,

    # defines a struct
    define := meth(self, o, i, is)
        local e, ee;
        for e in o.types do
            Print(Blanks(i), "struct {\n");
            for ee in e.getVars() do
                Print(Blanks(i+is));
                Print(self.declare(ee.t, [ee], i, is), ";\n");
            od;

            Print(Blanks(i), "} ", e.getName(), ";\n");
        od;
    end,

    tcast := (self, o, i, is) >> Print("((", self(o.args[2],i,is), ") as ", self.declare(o.args[1], [], i, is),")"),

    sizeof := (self, o, i, is) >> Print("std::mem::sizeof(", self.declare(o.args[1], [], i, is), ")"),

    declare := (self, t, vars, i, is) >> When(
        IsBound(self.(t.name)),
        self.(t.name)(t, When(IsList(vars), vars, [vars]), i, is),
        Error("Can't declare ", vars, " no method '", t.name, "' in ", self)),

    TVect := (self, t, vars, i, is) >> Print("__m128 ", self.infix(vars, ", ", i+is)),

    TComplex := (self, t, vars, i, is) >> Print(
        When(IsBound(self.opts.TComplexRusttype), self.opts.TComplexRusttype, "Complex<32> "), " ",
        self.infix(vars, ", ",i+is)),

    T_Complex := (self, t, vars, i, is) >> Print("Complex<32> ", self.declare(t.params[1], vars, i, is)), 

    T_Real  := (self, t, vars, i, is) >> Print(
        self.infix(vars, ", ",i+is),
        When(Length(vars)>1, "", ": "),
        Cond(
            t.params[1] = 128, "f128",
            t.params[1] = 80, "f80",   #x86 specific
            t.params[1] = 64, "f644",
            t.params[1] = 32, "f32",
            Error("Type is not supported")
        )),

    T_Int  := (self, t, vars, i, is) >> Print(
        self.infix(vars, ", ",i+is),
        ": ",
        Cond(
            t.params[1] = 64, "i64",
            t.params[1] = 32, "i32",
            t.params[1] = 16, "i16",
            t.params[1] = 8, "i8",
            Error("Type is not supported")
        )),

    T_UInt  := (self, t, vars, i, is) >> Print(Cond(
            t.params[1] = 64, "u64",
            t.params[1] = 32, "u32",
            t.params[1] = 16, "u16",
            t.params[1] = 8, "u8",
            t.params[1] = 1, "unsigned __bit",
            Error("Type is not supported")
        ), " ", self.infix(vars, ", ",i+is)),

    T_Struct := (self, t, vars, i, is) >> Print(
        t.getName(), " ", self.infix(vars, ", ", i+is)
    ),

    TReal  := (self, t, vars, i, is) >> Print(
        self.infix(vars, ", ",i+is),
        When(Length(vars)=0, "", ": "),
        When(IsBound(self.opts.TRealRusttype), self.opts.TRealRusttype, TReal.rusttype)),

    TInt  := (self, t, vars, i, is) >> Print(
        self.infix(vars, ", ",i+is),
        " :",
        When(IsBound(self.opts.TIntRusttype), self.opts.TIntRusttype, TInt.rusttype)),

    TDummy := ~.TInt,

    TBool  := (self, t, vars, i, is) >> Print(
        When(IsBound(self.opts.TIntRusttype), self.opts.TIntRusttype, TInt.rusttype), " ",
        self.infix(vars, ", ",i+is)),

    TUInt  := (self, t, vars, i, is) >> Print(
        When(IsBound(self.opts.TUIntRusttype), self.opts.TUIntRusttype, TUInt.rusttype), " ",
        self.infix(vars, ", ",i+is)),

    TULongLong  := (self, t, vars, i, is) >> Print(
        When(IsBound(self.opts.TULongLongRusttype), self.opts.TULongLongRusttype, TULongLong.rusttype), " ",
        self.infix(vars, ", ",i+is)),

    TChar  := (self, t, vars, i, is) >> Print(
        When(IsBound(self.opts.TCharRusttype), self.opts.TCharRusttype, TChar.rusttype), " ",
        self.infix(vars, ", ",i+is)),

    TUChar  := (self, t, vars, i, is) >> Print(
        When(IsBound(self.opts.TUCharRusttype), self.opts.TUCharRusttype, TUChar.rusttype), " ",
        self.infix(vars, ", ",i+is)),

    TVoid  := (self, t, vars, i, is) >> Print(Blanks(i), "#[allow(unused_parens)]\n", Blanks(i), "pub fn ", self.infix(vars, ", ",i+is)),

    _restrict := (self, t) >> let(opts := self.opts, rst := Concat(When(IsBound(opts.restrict),
                    opts.restrict(), "restrict"), " "), When(t._restrict, rst, "")),

    TPtr  := (self, t, vars, i, is) >>
        Print(Cond(not IsBound(t.qualifiers) or t.qualifiers=[], "", Print(self.infix(t.qualifiers, " "), " ")),
          Cond(vars=[],
          Print(self.declare(t.t, [], i, is), " *", self._restrict(t)),
          Print(self.declare(t.t, [], i, is),
              Print(" *", self._restrict(t) ),
              self.infix(vars, Concatenation(", *", self._restrict(t)), i+is)))),

    TSym := (self, t, vars, i, is) >> Print(t.id, " ", self.infix(vars, ", ")),

    _TFunc_args := (self, t, i, is) >> let(params := DropLast(t.params, 1),
        Print(
            DoForAllButLast(params, p -> Print(self.declare(p, [], i, is), ", ")),
            self.declare(Last(params), [], i, is))),

    TFunc  := (self, t, vars, i, is) >>
        Cond(Length(vars) in [0,1],
               PrintEvalF("$1 (*$2)($3)",
                 () -> self.declare(Last(t.params), [], i, is),
                 When(vars=[], "", vars[1].id),
                 () -> self._TFunc_args(t, i, is)),
               Print(
                   DoForAllButLast(vars, v -> Print(self.declare(t, v, i, is), ", ")),
                   self.declare(t, [Last(vars)], i, is))),

    TArray := meth(self,t,vars,i,is)
        local dims, elt, v, ptype, vsize, thedim;
        if Length(vars) > 1 then DoForAll(vars, v->Print(self.TArray(t, [v], i, is), "; "));
        elif Length(vars) = 0 then
            Print("[",self.(t.t.name)(t.t,[], i,is) , "; ", t.size, "]");
        else
            # at this point Length(vars)=1
            v := When(IsList(vars), vars[1], vars);
            dims := []; elt := t;
            while IsArray(elt) do Add(dims, elt.size); elt := elt.t; od;

          #NOTE: Ignoring twiddles by looking for "D" in .id
          # Better way: look for func.name="init" in parent/context
          if IsBound(self.opts.useMemoryArena) and self.opts.useMemoryArena and v.id[1] <> 'D' then
            #NOTE: Arena currently doesn't handle multiple dims.
            #NOTE: Slightly ugly hack to get this to be a pointer

            # To handle vectors. Arena is declared only for scalars. For
            # vectors, we must manually scale the allocation by vector length.
            vsize := 1; if ObjId(elt)=TVect then vsize := elt.size; fi;
#            ptype := Concatenation(elt.name, "Pointer");
#            self.(ptype)(elt, [v], i, is);
            self.TPtr(TPtr(elt), [v], i, is);
            Print(" =  &(ARENA[ (arenalevel-=",self(dims[1]*vsize,i,is),") ])");
          else
            for thedim in dims do
                Print(v, When(v.id="Y", ": &mut", ": &"), "[", self.(t.t.name)(t.t,[], i,is) , When(thedim=0, "", Concat("; ", thedim)), "]");
            od;
          fi;

        fi;
    end,

    # comments embedded in code

    comment := (self, o, i, is) >> When(Length(o.exp) = 0,
        PrintLine(),
        PrintLine(Blanks(i), "/* ", o.exp, " */")
    ),

    quote := (self, o, i, is) >> Print("\"", self(o.cmd,i,is), "\"")
));

# can handle program/func, etc
#
Class(RustUnparser, RustUnparserBase, rec(
    gen := meth(self, subname, o, opts)
        local oo;
        self.opts := CopyFields(opts, rec(subName := subname));
        oo := self.preprocess(o);
		self.checkPrintRuleTree(o, opts);
        Print(self.header(subname, oo), Unparse(oo, self, 0, 4), self.footer(subname, oo));
    end,

    fld := (self, o, i, is) >> Print(self(o.loc, i, is), When(IsPtrT(o.loc.t), "->", "."), o.id),
    ufld := ~.fld,

    header := (self, subname, o) >> Print(
        self.generated_by,
        self.extraHeader,
        self.fileinfo(self.opts),
        DoForAll(self.includes, inc -> Print("use ", inc, ";\n")),
        DoForAll(self.opts.includes, inc -> Print("use ", inc, ";\n"))
    ),
	
	checkPrintRuleTree := meth(self, o, opts)
		if IsBound(opts.printRuleTree) and opts.printRuleTree and IsBound(o.ruletree) then
			Print("/* RuleTree:\nrt :=\n");
			Print(o.ruletree);
			Print("\n;\n*/\n\n");
		fi;
	end,

    footer := Ignore,

    data := (self,o,i,is) >> Print(Blanks(i), self.genData(o.var, o.value), self(o.cmd, i, is)),

    func := (self, o, i, is) >> let(
        parameters:=Reversed(Flat(o.params)),
        id := o.id,
        Print("\n", Blanks(i),
            self.opts.funcModifier, self.declare(o.ret, var(id, o.ret), i, is), "(",
            Cond(
                o.id="transform",   "&",
                o.id="init",        "&mut ",
                o.id="destroy",     "&mut "),
            "self, ",
            DoForAllButLast(parameters, p->Print(self.declare(p.t, p,i,is), ", ")),
            When(Length(parameters)>0, self.declare(Last(parameters).t, Last(parameters),i,is), ""), ") ",
            "{\n",
            When(IsBound(self.opts.postalign), DoForAll(parameters, p->self.opts.postalign(p,i+is,is))),
            self(o.cmd, i+is, is),
            Blanks(i),
            "}\n"),
		When ((IsBound(self.opts.wrapCFuncs) and self.opts.wrapCFuncs), Print("}\n"))),

    # C99 style, loop var declared inside
    loop := (self, o, i, is) >> let(v := o.var, lo := o.range[1], hi := Last(o.range),
        Print(When(IsBound(self.opts.looppragma), self.opts.looppragma(o,i,is)),
          Blanks(i), "for ", v, " in ", lo, "..", hi, " {\n",
          self(o.cmd,i+is,is),
          Blanks(i), "}\n")),

    loopn := (self, o, i, is) >> let(v := o.var.id, lo := 0, hi := o.range,
        Print(Blanks(i), "for(int ", v, " = ", lo, "; ", v, " < ", self(hi,i,is), "; ", v, "++) {\n",
          self(o.cmd,i+is,is),
          Blanks(i), "}\n")),

    program := (self,o,i,is) >> DoForAll(o.cmds, c -> self(c,i,is)),

    allocate := (self, o, i, is) >> Print(Blanks(i),
        self(o.loc, i, is), " = (", self.declare(o.exp.t, [],0,0),
        "*) calloc(", self(o.exp.size,i,is), ", sizeof(", self.declare(o.exp.t,[],0,0), "));\n"),

    deallocate := (self, o, i, is) >> Print(
        Blanks(i),
        "free(",
        self(o.loc, i, is),
        ");\n"
    ),

    ret := (self, o, i, is) >> Print(Blanks(i), "return ", self(o.args[1], i+is, is), ";\n"),

    call := (self, o, i, is) >> Print(Blanks(i), o.args[1].id, self.pinfix(Drop(o.args, 1), ", "), ";\n"),

    fcall := (self, o, i, is) >> Print(
        self(o.args[1],0,0),
        "(", self.infix(Drop(o.args, 1), ", "), ")"),

    cospi := (self, o, i, is) >> Print(
        "cospi_rn(",
        self(o.args[1],0,0),
        ")"),

    sinpi := (self, o, i, is) >> Print(
        "sinpi_rn(",
        self(o.args[1],0,0),
        ")"),

    # structure definition
    struct := (self, o, i, is) >> Print(
        Blanks(i), "struct {\n",
        DoForAll(o.fields, f ->
            Print(Blanks(i+is), self.declare(f.t, f, i+is, is), ",\n")
        ),
        Blanks(i), "}\n\n"
    )
));

RustUnparserProg := RustUnparser;